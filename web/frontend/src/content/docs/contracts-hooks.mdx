---
title: Writing Hooks
description: How to author Hook contracts and when to use the built‑in TransferHook.
navGroup: Hooks
navOrder: 3
status: stable
---

## Interface

```solidity
interface ISettlementHook {
  function execute(
    bytes32 contextKey,
    address payer,
    address token,
    uint256 amount,
    bytes32 salt,
    address payTo,
    address facilitator,
    bytes calldata data
  ) external returns (bytes memory);
}
```

**Parameters:**
- `contextKey`: Settlement context identifier derived from the EIP-3009 nonce; uniquely ties the hook execution to a specific authorization.
- `payer`: Address that signed the EIP-3009 authorization
- `token`: Address of the payment token (e.g., USDC)
- `amount`: Amount of tokens available to Hook (after facilitator fee deduction)
- `salt`: Additional unique value generated by the Resource Server to ensure settlement uniqueness and prevent replay attacks (distinct from `contextKey`).
- `payTo`: Final recipient address (for transparency and UI display)
- `facilitator`: Address of the facilitator who submitted this transaction
- `data`: ABI-encoded hook-specific parameters

Rules:

- Only the SettlementRouter may call your hook (use an `onlyHub` guard)
- Consume the entire `amount` from the router (router must not retain funds)
- Keep business logic deterministic; any revert reverts the whole settlement
- Use provided parameters for transparency and logging (e.g., `payTo` for UI display, `facilitator` for fee attribution)

## Basic Template

```solidity
contract MyHook is ISettlementHook {
  using SafeERC20 for IERC20;

  address public immutable hub;
  modifier onlyHub() { require(msg.sender == hub, "Only hub"); _; }
  constructor(address _hub) { hub = _hub; }

  function execute(
    bytes32 /*contextKey*/,
    address /*payer*/,
    address token,
    uint256 amount,
    bytes32 /*salt*/,
    address payTo,
    address /*facilitator*/,
    bytes calldata data
  ) external onlyHub returns (bytes memory) {
    address recipient = abi.decode(data, (address));
    IERC20(token).safeTransferFrom(hub, recipient, amount);
    return abi.encode(recipient);
  }
}
```

## Built‑in TransferHook

- One per network; use for simple transfers with facilitator fee support
- Address helper: `TransferHook.getAddress(network)`
- Data encoder: `TransferHook.encode()` for simple transfer, or `encode([{recipient,bips}, ...])`
  for revenue splits (bips out of 10000)

```transfer-hook.ts
import { TransferHook } from "@x402x/extensions";
const hook = TransferHook.getAddress("base-sepolia");
const hookData = TransferHook.encode([{ recipient: "0xAlice...", bips: 3000 }]);
```

## Examples

See full contract examples under `contracts/examples/`:

- TransferHook — simple transfers and revenue splitting (built-in)
- NFTMintHook — mint to payer and distribute proceeds
- RewardHook — merchant payment + reward token to payer

More in: contracts/docs/hook_guide.md

import { RelatedLinks } from "@/components/docs/related-links";

## Related Docs

<RelatedLinks
  items={[
    {
      title: "Hook Development Guide",
      href: "https://github.com/nuwa-protocol/x402-exec/blob/main/contracts/docs/hook_guide.md",
      description: "Design patterns, templates, and best practices.",
    },
    {
      title: "Built‑in Hooks",
      href: "https://github.com/nuwa-protocol/x402-exec/blob/main/contracts/docs/builtin_hooks.md",
      description: "TransferHook and usage, gas notes, and migration tips.",
    },
    {
      title: "Security Guide",
      href: "https://github.com/nuwa-protocol/x402-exec/blob/main/contracts/docs/security.md",
      description: "Threat model, invariants, and secure hook authoring.",
    },
  ]}
/> 
