// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ISettlementHook} from "../../src/interfaces/ISettlementHook.sol";

/**
 * @notice Interface for reward token distribution
 */
interface IRewardToken {
    function distribute(address to, uint256 amount) external;
}

/**
 * @title RewardHook
 * @notice Settlement hook that transfers payment to merchant and distributes reward tokens
 * @dev Used in Scenario 3: Points Reward showcase
 * 
 * Architecture:
 * - Hook is deployed first as reusable infrastructure
 * - Multiple RewardToken contracts can use the same hook
 * - RewardToken address is passed via hookData at runtime
 * 
 * Flow:
 * 1. Receive payment authorization from SettlementRouter
 * 2. Transfer USDC to merchant
 * 3. Calculate reward points based on payment amount
 * 4. Distribute reward points to payer
 * 
 * Reward Rate:
 * - 1000 points per $0.1 USDC (0.1 USDC = 100,000 in 6 decimals)
 * - Example: Pay $0.1 â†’ Get 1000 points
 */
contract RewardHook is ISettlementHook {
    using SafeERC20 for IERC20;
    
    
    // ===== Constants & Immutables =====
    
    /// @notice Address of the SettlementRouter contract
    address public immutable settlementRouter;
    
    /// @notice Reward rate: points per $0.1 USDC
    /// @dev For 0.1 USDC (100,000 in 6 decimals), user gets 1000 points (1000 * 10^18)
    uint256 public constant REWARD_RATE = 1000;
    
    /// @notice Maximum amount eligible for rewards per transaction (0.1 USDC)
    /// @dev Prevents large transactions from draining the reward pool
    /// Payment amount exceeding this cap will only earn rewards based on the cap
    uint256 public constant MAX_REWARD_AMOUNT = 100_000; // 0.1 USDC in 6 decimals
    
    // ===== Data Structures =====
    
    /**
     * @notice Reward configuration
     * @param rewardToken Address of the reward token contract
     */
    struct RewardConfig {
        address rewardToken;
    }
    
    // ===== Events =====
    
    /// @notice Emitted when payment is processed and rewards are distributed
    event RewardDistributed(
        bytes32 indexed contextKey,
        address indexed payer,
        address indexed payTo,
        address rewardToken,
        uint256 paymentAmount,
        uint256 rewardPoints
    );
    
    // ===== Errors =====
    
    error OnlyRouter();
    error InvalidAddress();
    error RewardDistributionFailed();
    
    // ===== Modifiers =====
    
    modifier onlyRouter() {
        if (msg.sender != settlementRouter) revert OnlyRouter();
        _;
    }
    
    // ===== Constructor =====
    
    /**
     * @notice Initializes the reward hook
     * @param _settlementRouter Address of the SettlementRouter contract
     */
    constructor(address _settlementRouter) {
        require(_settlementRouter != address(0), "Invalid router address");
        settlementRouter = _settlementRouter;
    }
    
    // ===== External Functions =====
    
    /**
     * @notice Executes the reward distribution logic
     * @dev Called by SettlementRouter during settleAndExecute
     * @param contextKey Unique identifier for this settlement
     * @param payer Address of the payment sender
     * @param token Address of the payment token (USDC)
     * @param amount Payment amount in token's decimals (6 for USDC)
     * @param salt Unique identifier (generated by Resource Server)
     * @param payTo Merchant address (recipient of payment)
     * @param facilitator Address of the facilitator who submitted this transaction
     * @param data ABI-encoded RewardConfig struct
     * @return Encoded reward points amount
     */
    function execute(
        bytes32 contextKey,
        address payer,
        address token,
        uint256 amount,
        bytes32 salt,
        address payTo,
        address facilitator,
        bytes calldata data
    ) external onlyRouter returns (bytes memory) {
        // Decode configuration
        RewardConfig memory config = abi.decode(data, (RewardConfig));
        
        // Validate addresses
        if (config.rewardToken == address(0)) {
            revert InvalidAddress();
        }
        if (payTo == address(0)) {
            revert InvalidAddress();
        }
        
        // 1. Transfer payment to payTo (merchant)
        IERC20(token).safeTransferFrom(settlementRouter, payTo, amount);
        
        // 2. Calculate reward points with cap to prevent pool draining
        // Only amount up to MAX_REWARD_AMOUNT is eligible for rewards
        // Example: Pay 1 USDC, but only earn rewards for 0.1 USDC
        uint256 rewardableAmount = amount > MAX_REWARD_AMOUNT ? MAX_REWARD_AMOUNT : amount;
        
        uint256 rewardPoints;
        unchecked {
            // Safe because: rewardableAmount is capped at MAX_REWARD_AMOUNT (0.1 USDC)
            // Max possible: (100_000 * 1000 * 10^18) / 100_000 = 1000 * 10^18
            // This is much less than uint256 max and prevents reward pool from being drained
            rewardPoints = (rewardableAmount * REWARD_RATE * 10**18) / 100_000;
        }
        
        // 3. Distribute reward points to payer with error handling
        try IRewardToken(config.rewardToken).distribute(payer, rewardPoints) {
            // Success - emit event
            emit RewardDistributed(contextKey, payer, payTo, config.rewardToken, amount, rewardPoints);
        } catch {
            // If distribution fails, revert the entire transaction
            // This ensures atomicity: either payment + rewards both succeed, or both fail
            revert RewardDistributionFailed();
        }
        
        // Note: salt and facilitator parameters are available for advanced use cases
        // For example, facilitator could receive bonus points for bringing in customers
        
        // Return reward points for off-chain tracking
        return abi.encode(rewardPoints);
    }
}

